# 中断和异常

By: [:material-github: howardlau1999](https://github.com/howardlau1999)

在使用电脑的时候，你可以一边听音乐一边上网冲浪、一边在线聊天一边看视频，后台可能还挂着东西在下载。然而，真正同时运行的程序数量最多不会超过 CPU 的核心数，一般的电脑有 4 核，所以最多只能同时运行 4 个程序。另外，当你写的程序出 Bug 的时候，操作系统会帮你结束程序，并将程序结束的原因报告给你，而不会影响到其他程序的运行。

你或许已经知道，我们日常所使用的操作系统实际上是会不停地切换程序。然而，一旦程序开始运行，除非它主动跳转到其他程序，否则将永远独占一个核心，哪怕它是在死循环。这样的情况下，操作系统又如何获得 CPU 核心的使用权呢？答案是，我们日常所使用的 Windows 和 Linux 等操作系统是**抢占式调度**的。在操作系统启动的时候，它们会打开 CPU 上的定时器中断，也就是说，每隔一段时间，CPU 就会强行暂停当前运行的程序，并跳转到操作系统设置的中断处理程序中。这时，操作系统就有机会保存好进程的状态，并执行调度算法选择下一个需要运行的程序了。当然，除了抢占式调度，还有协作式调度，在这种调度方式中，需要程序员在代码中手动插入跳转到操作系统的代码，否则程序将一直运行下去。

而在程序出 Bug 的时候，例如访存越界、除零错误等，则会触发 CPU 中的异常，这时，CPU 同样会强行暂停目前的程序，跳转到操作系统预先设置好的异常处理程序中。这样，操作系统就可以记录下错误的原因，并调用程序员设置好的异常处理程序来处理错误。当然，你也很少编写自己的异常处理程序，那么，操作系统便会默认地将你的进程结束掉了。

在本实验中，你将通过实践了解 CPU 的中断和异常是如何实现的，CPU 是如何打断正常的执行流进入中断和异常处理程序的，又是如何告诉中断处理程序必要的信息，以及如何从中断处理程序返回到正常的执行流中。